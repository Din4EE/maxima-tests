### Ответ
```
result: 6
fatal error: all goroutines are asleep - deadlock!
```
В этом задании используется примитив синхронизации - `WaitGroup`.
Он позволяет дождаться выполнения всех горутин, а после того как горутины отработали, разблокировать поток для последующего выполнения программы.
```go
wg.Add(3)
for i := 0; i < 3; i++ {
    go func(idx int) {
        ch <- (idx + 1) * 2
        wg.Done()
    }(i)
}
fmt.Printf("result: %d\n", <-ch)
wg.Wait()
```
Мы объявляем счетчик и ставим значение 3, так как мы хотим запустить три горутины и синхронизировать их выполнение.

Мы также объявили небуферизированный канал для связи между горутинами

```go
ch := make(chan int)
```

При использовании небуферизированного канала горутина, которая пытается отправить данные в канал, блокируется до тех пор, пока другая горутина не прочитает данные из канала.
И также горутина, которая пытается прочитать данные из канала, блокируется до тех пор, пока другая горутина не отправит данные в канал.

Потенциальные блокировки могут возникнуть в трех местах программы:

```go
ch <- (idx + 1) * 2
```

```go
fmt.Printf("result: %d\n", <-ch)
```
и
```go
wg.Wait()
```
Так как чтение у нас происходит только 1 раз, то следующая горутина которая запишет в канал ждет, что из него прочитает другая горутина, но такого уже никогда не произойдет, мы получаем `deadlock`.

Решений здесь может быть следующее:

Можно заметить, что после отправки последнего значения мы не закрываем канал, что может привести к утечке горутин.

Для этого нужно переместить `wg.Wait()` и `close(ch)` в отдельную горутину, чтобы мы не блокировались в `main` горутине и смогли в ней считывать значения, которые придут в канал.

```go
go func() {
    wg.Wait()
    close(ch)
}()
```

Таким образом мы заблокируемся в `main` горутине только в 1 месте и там же прочитаем значения из канала
```go
for v := range ch {
    fmt.Printf("result: %d\n", v) //blocked cause of empty channel
}
```
В этом случае мы не получим `deadlock`, так как канал у нас закрывается после `wg.Wait()` и читать из него нам больше не нужно, `main` продолжит выполняться дальше.

