### Ответ

```text
three
three
three
```

Попробуем запустить с флагом --race:

```text
go run --race test7.go  
```
И увидим:

```text
three
three
==================
WARNING: DATA RACE
```
Мы имеем состояние гонки (Race Condition) из-за которой результат программы может быть неопределенным.

Каждая из горутин, которые вы запускаете в цикле, использует переменную `v`, значение которой изменяется на каждой итерации цикла `for`. Поскольку горутины выполняются асинхронно, они могут получить доступ к переменной `v` после того, как её значение уже изменилось.

А также переменная `v` будет захвачена замыканием (closure) внутри анонимной функции горутины по адресу в памяти. 

Поскольку цикл может завершиться до того, как горутины начнут выполняться (или даже закончат своё выполнение), все горутины могут вывести на экран значение `v` из последней итерации цикла, что в данном случае будет "three".

Чтобы исправить эту проблему и гарантировать, что каждая горутина печатает соответствующее значение, которое было в `v` во время её итерации, нужно передать `v` как копию в функцию горутины.

Таким образом решение задачи может быть таким:

```go
func main() {
	// Какой будет результат выполнения приложения
	wg := sync.WaitGroup{}
	data := []string{"one", "two", "three"}
	for _, v := range data {
		wg.Add(1)
		go func(v string) {
			fmt.Println(v)
			wg.Done()
		}(v)
	}
	wg.Wait()
}
```

Или по аналогии с предыдущим заданием объявить новую переменную и записать значение переменной `v` в нее:

```go
func main() {
	// Какой будет результат выполнения приложения
	wg := sync.WaitGroup{}
	data := []string{"one", "two", "three"}
	for _, v := range data {
		text := v
		wg.Add(1)
		go func() {
			fmt.Println(text)
			wg.Done()
		}()
	}
	wg.Wait()
```
В этом случае переменная `text` всегда будет иметь разный адрес в памяти.
